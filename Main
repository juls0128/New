import tkinter as tk
import threading
import time

running = False  # Flag to control the loop

def auto_coin_loop():
    """Simulated auto-coin process."""
    global running
    while running:
        print("Collecting coins... ðŸ’°")
        # TODO: Replace this with your real coin-collecting logic
        time.sleep(2)  # Wait 2 seconds between actions
    print("Auto coin stopped.")

def start_auto_coin():
    global running
    if not running:
        running = True
        status_label.config(text="Status: Running", fg="green")
        threading.Thread(target=auto_coin_loop, daemon=True).start()

def stop_auto_coin():
    global running
    running = False
    status_label.config(text="Status: Stopped", fg="red")

# --- GUI Setup ---
root = tk.Tk()
root.title("Raine - Auto Coin")
root.geometry("300x200")
root.resizable(False, False)

title_label = tk.Label(root, text="Raine's Auto Coin", font=("Arial", 14, "bold"))
title_label.pack(pady=15)

status_label = tk.Label(root, text="Status: Stopped", fg="red", font=("Arial", 12))
status_label.pack(pady=10)

start_button = tk.Button(root, text="Start", width=10, bg="green", fg="white", command=start_auto_coin)
start_button.pack(pady=5)

stop_button = tk.Button(root, text="Stop", width=10, bg="red", fg="white", command=stop_auto_coin)
stop_button.pack(pady=5)

root.mainloop()

-- Create objects
local parent = nil;
local objects = {
	["Instance0"] = Instance.new("ScreenGui"); -- OctoSpy
	["Instance1"] = Instance.new("LocalScript"); -- Main
	["Instance2"] = Instance.new("ModuleScript"); -- CodeBox
	["Instance3"] = Instance.new("TextButton"); -- Window
	["Instance4"] = Instance.new("TextLabel"); -- Title
	["Instance5"] = Instance.new("TextButton"); -- Close
	["Instance6"] = Instance.new("TextButton"); -- Toggle
	["Instance7"] = Instance.new("ImageLabel"); -- State
	["Instance8"] = Instance.new("Frame"); -- WindowView
	["Instance9"] = Instance.new("Frame"); -- Shadow
	["Instance10"] = Instance.new("Folder"); -- Stroke
	["Instance11"] = Instance.new("Frame"); -- Left
	["Instance12"] = Instance.new("Frame"); -- Right
	["Instance13"] = Instance.new("Frame"); -- Bottom
	["Instance14"] = Instance.new("Frame"); -- Logs
	["Instance15"] = Instance.new("ScrollingFrame"); -- To
	["Instance16"] = Instance.new("UIListLayout"); -- UIListLayout
	["Instance17"] = Instance.new("ScrollingFrame"); -- From
	["Instance18"] = Instance.new("UIListLayout"); -- UIListLayout
	["Instance19"] = Instance.new("TextButton"); -- Log
	["Instance20"] = Instance.new("Frame"); -- Display
	["Instance21"] = Instance.new("Frame"); -- Type
	["Instance22"] = Instance.new("UIStroke"); -- UIStroke
	["Instance23"] = Instance.new("TextLabel"); -- RName
	["Instance24"] = Instance.new("Frame"); -- Selection
	["Instance25"] = Instance.new("Frame"); -- FromServer
	["Instance26"] = Instance.new("TextButton"); -- Scale
	["Instance27"] = Instance.new("Frame"); -- ContentView
	["Instance28"] = Instance.new("ScrollingFrame"); -- ScrollingFrame
	["Instance29"] = Instance.new("UIGridLayout"); -- UIGridLayout
	["Instance30"] = Instance.new("Frame"); -- ButtonRow
	["Instance31"] = Instance.new("Frame"); -- Display
	["Instance32"] = Instance.new("UIStroke"); -- UIStroke
	["Instance33"] = Instance.new("Frame"); -- Type_BUTTON
	["Instance34"] = Instance.new("TextLabel"); -- RName
	["Instance35"] = Instance.new("TextButton"); -- Button
	["Instance36"] = Instance.new("Frame"); -- Shadow
	["Instance37"] = Instance.new("TextBox"); -- CodeBox
	["Instance38"] = Instance.new("UIStroke"); -- UIStroke
	["Instance39"] = Instance.new("TextButton"); -- Toggle2
	["Instance40"] = Instance.new("ImageLabel"); -- Picture
	["Instance41"] = Instance.new("ImageLabel"); -- State
	["Instance42"] = Instance.new("TextButton"); -- Help
	["Instance43"] = Instance.new("ImageLabel"); -- Picture
	["Instance44"] = Instance.new("Frame"); -- Notifications
	["Instance45"] = Instance.new("Frame"); -- NotificationBase
	["Instance46"] = Instance.new("Frame"); -- Display
	["Instance47"] = Instance.new("UIStroke"); -- UIStroke
	["Instance48"] = Instance.new("Frame"); -- Bar
	["Instance49"] = Instance.new("Frame"); -- Frame
	["Instance50"] = Instance.new("TextLabel"); -- Title
	["Instance51"] = Instance.new("UIPadding"); -- UIPadding
	["Instance52"] = Instance.new("TextLabel"); -- Content
	["Instance53"] = Instance.new("UIListLayout"); -- UIListLayout
	["Instance54"] = Instance.new("Frame"); -- PCNotification
	["Instance55"] = Instance.new("UIStroke"); -- UIStroke
	["Instance56"] = Instance.new("TextLabel"); -- Title
	["Instance57"] = Instance.new("Frame"); -- Exit
	["Instance58"] = Instance.new("Frame"); -- Display
	["Instance59"] = Instance.new("UIStroke"); -- UIStroke
	["Instance60"] = Instance.new("Frame"); -- Type_BUTTON
	["Instance61"] = Instance.new("TextLabel"); -- RName
	["Instance62"] = Instance.new("TextButton"); -- Button
	["Instance63"] = Instance.new("TextLabel"); -- Text
	["Instance64"] = Instance.new("Frame"); -- Next
	["Instance65"] = Instance.new("Frame"); -- Display
	["Instance66"] = Instance.new("UIStroke"); -- UIStroke
	["Instance67"] = Instance.new("Frame"); -- Type_BUTTON
	["Instance68"] = Instance.new("TextLabel"); -- RName
	["Instance69"] = Instance.new("TextButton"); -- Button
	["Instance70"] = Instance.new("Frame"); -- Previous
	["Instance71"] = Instance.new("Frame"); -- Display
	["Instance72"] = Instance.new("UIStroke"); -- UIStroke
	["Instance73"] = Instance.new("Frame"); -- Type_BUTTON
	["Instance74"] = Instance.new("TextLabel"); -- RName
	["Instance75"] = Instance.new("TextButton"); -- Button
	["Instance76"] = Instance.new("Frame"); -- Load
	["Instance77"] = Instance.new("Frame"); -- Display
	["Instance78"] = Instance.new("UIStroke"); -- UIStroke
	["Instance79"] = Instance.new("Frame"); -- Type_BUTTON
	["Instance80"] = Instance.new("TextLabel"); -- RName
	["Instance81"] = Instance.new("TextButton"); -- Button
};

-- Set modules
local o_require = require; local require;
local modules do
	modules = {};
	require = function(object)
		if modules[object] then
			return modules[object]();
		end
		return o_require(object);
	end;

	getfenv().require = require;

	modules[objects["Instance2"]] = function()
		local script = objects["Instance2"];
		local Lib = {}
		local function getFunc(name)
			return getfenv()[name]
		end
		local ENV = {
			game=game,
			Instance=Instance,
			type=type,
			typeof=typeof,
			wait=wait,
			workspace=workspace,
			Wait=wait,
			Workspace=workspace,
			Enum=Enum,
			ElapsedTime=getFunc("elapsedTime"),
			elapsedTime=getFunc("elapsedTime"),
			require=require,
			Random=Random,
			RaycastParams=RaycastParams,
			Region3=Region3,
			Ray=Ray,
			Rect=Rect,
			RotationCurveKey=RotationCurveKey,
			Region3int16=Region3int16,
			rawget=rawget,
			rawlen=rawlen,
			rawset=rawset,
			rawequal=rawequal,
			task=task,
			TweenInfo=TweenInfo,
			tostring=tostring,
			tonumber=tonumber,
			table=table,
			time=time,
			tick=tick,
			ypcall=pcall,
			UDim2=UDim2,
			utf8=utf8,
			unpack=unpack,
			UDim=UDim,
			UserSettings=UserSettings,
			ipairs=ipairs,
			os=os,
			OverlapParams=OverlapParams,
			pairs=pairs,
			pcall=pcall,
			plugin=plugin,
			PhysicalProperties=PhysicalProperties,
			PathWaypoint=PathWaypoint,
			printidentity=getFunc("printidentity"),
			Axes=Axes,
			assert=assert,
			script=nil,
			string=string,
			select=select,
			settings=settings,
			spawn=spawn,
			Secret=Secret,
			shared=shared,
			setfenv=setfenv,
			SharedTable=SharedTable,
			setmetatable=setmetatable,
			Spawn=spawn,
			Stats=getFunc("stats"),
			stats=getFunc("stats"),
			DateTime=DateTime,
			debug=debug,
			DockWidgetPluginGuiInfo=DockWidgetPluginGuiInfo,
			delay=delay,
			Delay=delay,
			Font=Font,
			Faces=Faces,
			File=File,
			FloatCurveKey=FloatCurveKey,
			getfenv=getfenv,
			getmetatable=getmetatable,
			gcinfo=gcinfo,
			Game=getFunc("Game"),
			loadstring=loadstring,
			xpcall=xpcall,
			CFrame=CFrame,
			Color3=Color3,
			coroutine=coroutine,
			ColorSequenceKeypoint=ColorSequenceKeypoint,
			ColorSequence=ColorSequence,
			CatalogSearchParams=CatalogSearchParams,
			collectgarbage=getFunc("collectgarbage"),
			Vector3=Vector3,
			Vector2=Vector2,
			Vector2int16=Vector2int16,
			Vector3int16=Vector3int16,
			Version=getFunc("version"),
			version=getFunc("version"),
			BrickColor=BrickColor,
			bit32=bit32,
			buffer=buffer,
			newproxy=newproxy,
			NumberSequence=NumberSequence,
			NumberSequenceKeypoint=NumberSequenceKeypoint,
			NumberRange=NumberRange,
			next=next,
			math=math,
			_G={},
			_VERSION=_VERSION,
			print=print,
			warn=warn,
			error=error,
		}
		local Main = {}
		local plr = game:GetService("Players").LocalPlayer
		Main.Mouse = plr and plr:GetMouse()
		local service = setmetatable({},{
			__index = function(self,name)
				return game:FindFirstChild(name) or game:GetService(name)
			end,
		})
local Main = {}
		local plr = game:GetService("Players").LocalPlayer
		Main.Mouse = plr and plr:GetMouse()
		local service = setmetatable({},{
			__index = function(self,name)
				return game:FindFirstChild(name) or game:GetService(name)
			end,
		})
		local cloneref = function(...)return...end
		local clonerefs = cloneref
		local create = function(data)
			local insts = {}
			for i,v in pairs(data) do insts[v[1]] = Instance.new(v[2]) end
			for _,v in pairs(data) do
				for prop,val in pairs(v[3]) do
					if type(val) == "table" then
						insts[v[1]][prop] = insts[val[1]]
					else
						insts[v[1]][prop] = val
					end
				end
			end
			return insts[1]
		end
		local createSimple = function(class,props)
			local inst = Instance.new(class)
			for i,v in next,props do
				inst[i] = v
			end
			return inst
		end
		local Settings = {
			Explorer = {
				_Recurse = true,
				Sorting = true,
				TeleportToOffset = Vector3.new(0,0,0),
				ClickToRename = true,
				AutoUpdateSearch = true,
				AutoUpdateMode = 0, -- 0 Default, 1 no tree update, 2 no descendant events, 3 frozen
				PartSelectionBox = true,
				GuiSelectionBox = true,
				CopyPathUseGetChildren = true
			},
			Properties = {
				_Recurse = true,
				MaxConflictCheck = 50,
				ShowDeprecated = false,
				ShowHidden = false,
				ClearOnFocus = false,
				LoadstringInput = true,
				NumberRounding = 3,
				ShowAttributes = false,
				MaxAttributes = 50,
				ScaleType = 1 -- 0 Full Name Shown, 1 Equal Halves
			},
			Theme = {
				_Recurse = true,
				Main1 = Color3.fromRGB(52,52,52),
				Main2 = Color3.fromRGB(45,45,45),
				Outline1 = Color3.fromRGB(33,33,33), -- Mainly frames
				Outline2 = Color3.fromRGB(55,55,55), -- Mainly button
				Outline3 = Color3.fromRGB(30,30,30), -- Mainly textbox
				TextBox = Color3.fromRGB(38,38,38),
				Menu = Color3.fromRGB(32,32,32),
				ListSelection = Color3.fromRGB(199,154,40),
				Button = Color3.fromRGB(60,60,60),
				ButtonHover = Color3.fromRGB(68,68,68),
				ButtonPress = Color3.fromRGB(40,40,40),
				Highlight = Color3.fromRGB(75,75,75),
				Text = Color3.fromRGB(255,255,255),
				PlaceholderText = Color3.fromRGB(100,100,100),
				Important = Color3.fromRGB(255,0,0),
				ExplorerIconMap = "",
				MiscIconMap = "",
				Syntax = {
					Text = Color3.fromRGB(204,204,204),
					Background = Color3.fromRGB(18,18,25),
					Selection = Color3.fromRGB(255,255,255),
					SelectionBack = Color3.fromRGB(66, 0, 50),
					Operator = Color3.fromRGB(204,204,204),
					Number = Color3.fromRGB(170, 170, 255),
					String = Color3.fromRGB(255, 85, 255),
					Comment = Color3.fromRGB(102,102,102),
					Keyword = Color3.fromRGB(255, 0, 127),
					Error = Color3.fromRGB(255,0,0),
					FindBackground = Color3.fromRGB(255, 170, 0),
					MatchingWord = Color3.fromRGB(85,85,85),
					BuiltIn = Color3.fromRGB(170, 85, 255),
					CurrentLine = Color3.fromRGB(45,50,65),
					LocalMethod = Color3.fromRGB(255, 170, 255),
					LocalProperty = Color3.fromRGB(255, 170, 255),
					Nil = Color3.fromRGB(255, 0, 255),
					Bool = Color3.fromRGB(255, 0, 255),
					Function = Color3.fromRGB(255, 0, 127),
					Local = Color3.fromRGB(255, 0, 127),
					Self = Color3.fromRGB(255, 0, 127),
					FunctionName = Color3.fromRGB(255, 170, 255),
					Bracket = Color3.fromRGB(204,204,204)
				},
			}
		}
local function signalWait(s)return s:Wait()end
		local renderStepped = game["Run Service"].RenderStepped
		Lib.FastWait = function(s)
			if not s then return signalWait(renderStepped) end
			local start = tick()
			while tick() - start < s do signalWait(renderStepped) end
		end
		Lib.CheckMouseInGui = function(gui)
			if gui == nil then return false end
			Main.Mouse = Main.Mouse or plr and plr:GetMouse()
			local mouse = Main.Mouse
			local guiPosition = gui.AbsolutePosition
			local guiSize = gui.AbsoluteSize    

			return mouse.X >= guiPosition.X and mouse.X < guiPosition.X + guiSize.X and mouse.Y >= guiPosition.Y and mouse.Y < guiPosition.Y + guiSize.Y
		end
		Lib.CreateArrow = function(size,num,dir)
			local max = num
			local arrowFrame = createSimple("Frame",{
				BackgroundTransparency = 1,
				Name = "Arrow",
				Size = UDim2.new(0,size,0,size)
			})
			if dir == "up" then
				for i = 1,num do
					local newLine = createSimple("TextButton",{
						BackgroundColor3 = Color3.new(220/255,220/255,220/255),
						BorderSizePixel = 0,
						Position = UDim2.new(0,math.floor(size/2)-(i-1),0,math.floor(size/2)+i-math.floor(max/2)-1),
						Size = UDim2.new(0,i+(i-1),0,1),
						Parent = arrowFrame,
						Text = "",
						AutoButtonColor = false
					})
				end
				return arrowFrame
			elseif dir == "down" then
				for i = 1,num do
					local newLine = createSimple("TextButton",{
						BackgroundColor3 = Color3.new(220/255,220/255,220/255),
						BorderSizePixel = 0,
						Position = UDim2.new(0,math.floor(size/2)-(i-1),0,math.floor(size/2)-i+math.floor(max/2)+1),
						Size = UDim2.new(0,i+(i-1),0,1),
						Parent = arrowFrame,
						Text = "",
						AutoButtonColor = false
					})
				end
				return arrowFrame
			elseif dir == "left" then
				for i = 1,num do
					local newLine = createSimple("TextButton",{
						BackgroundColor3 = Color3.new(220/255,220/255,220/255),
						BorderSizePixel = 0,
						Position = UDim2.new(0,math.floor(size/2)+i-math.floor(max/2)-1,0,math.floor(size/2)-(i-1)),
						Size = UDim2.new(0,1,0,i+(i-1)),
						Parent = arrowFrame,
						Text = "",
						AutoButtonColor = false
					})
				end
				return arrowFrame
			elseif dir == "right" then
				for i = 1,num do
					local newLine = createSimple("TextButton",{
						BackgroundColor3 = Color3.new(220/255,220/255,220/255),
						BorderSizePixel = 0,
						Position = UDim2.new(0,math.floor(size/2)-i+math.floor(max/2)+1,0,math.floor(size/2)-(i-1)),
						Size = UDim2.new(0,1,0,i+(i-1)),
						Parent = arrowFrame,
						Text = "",
						AutoButtonColor = false
					})
				end
				return arrowFrame
			end
			error("r u ok")
		end
		Lib.Signal = (function()
			local funcs = {}

			local disconnect = function(con)
				local pos = table.find(con.Signal.Connections,con)
				if pos then table.remove(con.Signal.Connections,pos) end
			end

			funcs.Connect = function(self,func)
				if type(func) ~= "function" then error("Attempt to connect a non-function") end        
				local con = {
					Signal = self,
					Func = func,
					Disconnect = disconnect
				}
				self.Connections[#self.Connections+1] = con
				return con
			end

			funcs.Fire = function(self,...)
				for i,v in next,self.Connections do
					xpcall(coroutine.wrap(v.Func),function(e) warn(e.."\n"..debug.traceback()) end,...)
				end
			end

			local mt = {
				__index = funcs,
				__tostring = function(self)
					return "Signal: " .. tostring(#self.Connections) .. " Connections"
				end
			}

			local function new()
				local obj = {}
				obj.Connections = {}

				return setmetatable(obj,mt)
			end

return {new = new}
		end)()
		Lib.ScrollBar = (function()
			local funcs = {}
			local user = service.UserInputService
			local mouse = Main.Mouse or plr and plr:GetMouse()
			local checkMouseInGui = Lib.CheckMouseInGui
			local createArrow = Lib.CreateArrow

			local function drawThumb(self)
				local total = self.TotalSpace
				local visible = self.VisibleSpace
				local index = self.Index
				local scrollThumb = self.GuiElems.ScrollThumb
				local scrollThumbFrame = self.GuiElems.ScrollThumbFrame

				if not (self:CanScrollUp()    or self:CanScrollDown()) then
					scrollThumb.Visible = false
				else
					scrollThumb.Visible = true
				end

				if self.Horizontal then
					scrollThumb.Size = UDim2.new(visible/total,0,1,0)
					if scrollThumb.AbsoluteSize.X < 16 then
						scrollThumb.Size = UDim2.new(0,16,1,0)
					end
					local fs = scrollThumbFrame.AbsoluteSize.X
					local bs = scrollThumb.AbsoluteSize.X
					scrollThumb.Position = UDim2.new(self:GetScrollPercent()*(fs-bs)/fs,0,0,0)
				else
					scrollThumb.Size = UDim2.new(1,0,visible/total,0)
					if scrollThumb.AbsoluteSize.Y < 16 then
						scrollThumb.Size = UDim2.new(1,0,0,16)
					end
					local fs = scrollThumbFrame.AbsoluteSize.Y
					local bs = scrollThumb.AbsoluteSize.Y
					scrollThumb.Position = UDim2.new(0,0,self:GetScrollPercent()*(fs-bs)/fs,0)
				end
			end

			local function createFrame(self)
				local newFrame = createSimple("Frame",{Style=0,Active=true,AnchorPoint=Vector2.new(0,0),BackgroundColor3=Color3.new(0.35294118523598,0.35294118523598,0.35294118523598),BackgroundTransparency=0,BorderColor3=Color3.new(0.10588236153126,0.16470588743687,0.20784315466881),BorderSizePixel=0,ClipsDescendants=false,Draggable=false,Position=UDim2.new(1,-16,0,0),Rotation=0,Selectable=false,Size=UDim2.new(0,16,1,0),SizeConstraint=0,Visible=true,ZIndex=1,Name="ScrollBar",})
				local button1 = nil
				local button2 = nil

				if self.Horizontal then
					newFrame.Size = UDim2.new(1,0,0,16)
					button1 = createSimple("ImageButton",{
						Parent = newFrame,
						Name = "Left",
						Size = UDim2.new(0,16,0,16),
						BackgroundTransparency = 1,
						BorderSizePixel = 0,
						AutoButtonColor = false
					})
					createArrow(16,4,"left").Parent = button1
					button2 = createSimple("ImageButton",{
						Parent = newFrame,
						Name = "Right",
						Position = UDim2.new(1,-16,0,0),
						Size = UDim2.new(0,16,0,16),
						BackgroundTransparency = 1,
						BorderSizePixel = 0,
						AutoButtonColor = false
					})
					createArrow(16,4,"right").Parent = button2
				else
					newFrame.Size = UDim2.new(0,16,1,0)
					button1 = createSimple("ImageButton",{
						Parent = newFrame,
						Name = "Up",
						Size = UDim2.new(0,16,0,16),
						BackgroundTransparency = 1,
						BorderSizePixel = 0,
						AutoButtonColor = false
					})
					createArrow(16,4,"up").Parent = button1
					button2 = createSimple("ImageButton",{
						Parent = newFrame,
						Name = "Down",
						Position = UDim2.new(0,0,1,-16),
						Size = UDim2.new(0,16,0,16),
						BackgroundTransparency = 1,
						BorderSizePixel = 0,
						AutoButtonColor = false
					})
					createArrow(16,4,"down").Parent = button2
				end

				local scrollThumbFrame = createSimple("Frame",{
					BackgroundTransparency = 1,
					Parent = newFrame,
				})
				if self.Horizontal then
					scrollThumbFrame.Position = UDim2.new(0,16,0,0)
					scrollThumbFrame.Size = UDim2.new(1,-32,1,0)
				else
					scrollThumbFrame.Position = UDim2.new(0,0,0,16)
					scrollThumbFrame.Size = UDim2.new(1,0,1,-32)
				end

				local scrollThumb = createSimple("TextButton",{
					BackgroundColor3 = Color3.new(120/255,120/255,120/255),
					BorderSizePixel = 0,
					Parent = scrollThumbFrame,
					Text = "",
					AutoButtonColor = false,
				})

				local markerFrame = createSimple("Frame",{
					BackgroundTransparency = 1,
					Name = "Markers",
					Size = UDim2.new(1,0,1,0),
					Parent = scrollThumbFrame
				})

local buttonPress = false
				local thumbPress = false
				local thumbFramePress = false

				--local thumbColor = Color3.new(120/255,120/255,120/255)
				--local thumbSelectColor = Color3.new(140/255,140/255,140/255)
				button1.InputBegan:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseMovement and not buttonPress and self:CanScrollUp() then button1.BackgroundTransparency = 0.8 end
					if input.UserInputType ~= Enum.UserInputType.MouseButton1 and input.UserInputType ~= Enum.UserInputType.Touch or not self:CanScrollUp() then return end
					buttonPress = true
					button1.BackgroundTransparency = 0.5
					if self:CanScrollUp() then self:ScrollUp() self.Scrolled:Fire() end
					local buttonTick = tick()
					local releaseEvent
					releaseEvent = user.InputEnded:Connect(function(input)
						if input.UserInputType ~= Enum.UserInputType.MouseButton1 and input.UserInputType ~= Enum.UserInputType.Touch then return end
						releaseEvent:Disconnect()
						if checkMouseInGui(button1) and self:CanScrollUp() then button1.BackgroundTransparency = 0.8 else button1.BackgroundTransparency = 1 end
						buttonPress = false
					end)
					while buttonPress do
						if tick() - buttonTick >= 0.3 and self:CanScrollUp() then
							self:ScrollUp()
							self.Scrolled:Fire()
						end
						wait()
					end
				end)
				button1.InputEnded:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseMovement and not buttonPress then button1.BackgroundTransparency = 1 end
				end)
				button2.InputBegan:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseMovement and not buttonPress and self:CanScrollDown() then button2.BackgroundTransparency = 0.8 end
					if input.UserInputType ~= Enum.UserInputType.MouseButton1 and input.UserInputType ~= Enum.UserInputType.Touch or not self:CanScrollDown() then return end
					buttonPress = true
					button2.BackgroundTransparency = 0.5
					if self:CanScrollDown() then self:ScrollDown() self.Scrolled:Fire() end
					local buttonTick = tick()
					local releaseEvent
					releaseEvent = user.InputEnded:Connect(function(input)
						if input.UserInputType ~= Enum.UserInputType.MouseButton1 and input.UserInputType ~= Enum.UserInputType.Touch then return end
						releaseEvent:Disconnect()
						if checkMouseInGui(button2) and self:CanScrollDown() then button2.BackgroundTransparency = 0.8 else button2.BackgroundTransparency = 1 end
						buttonPress = false
					end)
					while buttonPress do
						if tick() - buttonTick >= 0.3 and self:CanScrollDown() then
							self:ScrollDown()
							self.Scrolled:Fire()
						end
						wait()
					end
				end)
				button2.InputEnded:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseMovement and not buttonPress then button2.BackgroundTransparency = 1 end
				end)

				scrollThumb.InputBegan:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseMovement and not thumbPress then scrollThumb.BackgroundTransparency = 0.2 scrollThumb.BackgroundColor3 = self.ThumbSelectColor end
					if input.UserInputType ~= Enum.UserInputType.MouseButton1 and input.UserInputType ~= Enum.UserInputType.Touch then return end

					local dir = self.Horizontal and "X" or "Y"
					local lastThumbPos = nil

					buttonPress = false
					thumbFramePress = false            
					thumbPress = true
					scrollThumb.BackgroundTransparency = 0
					local mouseOffset = mouse[dir] - scrollThumb.AbsolutePosition[dir]
					local mouseStart = mouse[dir]
					local releaseEvent
					local mouseEvent
					releaseEvent = user.InputEnded:Connect(function(input)
						if input.UserInputType ~= Enum.UserInputType.MouseButton1 and input.UserInputType ~= Enum.UserInputType.Touch then return end
						releaseEvent:Disconnect()
						if mouseEvent then mouseEvent:Disconnect() end
						if checkMouseInGui(scrollThumb) then scrollThumb.BackgroundTransparency = 0.2 else scrollThumb.BackgroundTransparency = 0 scrollThumb.BackgroundColor3 = self.ThumbColor end
						thumbPress = false
					end)
					self:Update()
mouseEvent = user.InputChanged:Connect(function(input)
						if input.UserInputType == Enum.UserInputType.MouseMovement and thumbPress and releaseEvent.Connected then
							local thumbFrameSize = scrollThumbFrame.AbsoluteSize[dir]-scrollThumb.AbsoluteSize[dir]
							local pos = mouse[dir] - scrollThumbFrame.AbsolutePosition[dir] - mouseOffset
							if pos > thumbFrameSize then
								pos = thumbFrameSize
							elseif pos < 0 then
								pos = 0
							end
							if lastThumbPos ~= pos then
								lastThumbPos = pos
								self:ScrollTo(math.floor(0.5+pos/thumbFrameSize*(self.TotalSpace-self.VisibleSpace)))
							end
							wait()
						end
					end)
				end)
				scrollThumb.InputEnded:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseMovement and not thumbPress then scrollThumb.BackgroundTransparency = 0 scrollThumb.BackgroundColor3 = self.ThumbColor end
				end)
				scrollThumbFrame.InputBegan:Connect(function(input)
					if input.UserInputType ~= Enum.UserInputType.MouseButton1 and input.UserInputType ~= Enum.UserInputType.Touch or checkMouseInGui(scrollThumb) then return end

					local dir = self.Horizontal and "X" or "Y"
					local scrollDir = 0
					if mouse[dir] >= scrollThumb.AbsolutePosition[dir] + scrollThumb.AbsoluteSize[dir] then
						scrollDir = 1
					end

					local function doTick()
						local scrollSize = self.VisibleSpace - 1
						if scrollDir == 0 and mouse[dir] < scrollThumb.AbsolutePosition[dir] then
							self:ScrollTo(self.Index - scrollSize)
						elseif scrollDir == 1 and mouse[dir] >= scrollThumb.AbsolutePosition[dir] + scrollThumb.AbsoluteSize[dir] then
							self:ScrollTo(self.Index + scrollSize)
						end
					end

					thumbPress = false            
					thumbFramePress = true
					doTick()
					local thumbFrameTick = tick()
					local releaseEvent
					releaseEvent = user.InputEnded:Connect(function(input)
						if input.UserInputType ~= Enum.UserInputType.MouseButton1 and input.UserInputType ~= Enum.UserInputType.Touch then return end
						releaseEvent:Disconnect()
						thumbFramePress = false
					end)
					while thumbFramePress do
						if tick() - thumbFrameTick >= 0.3 and checkMouseInGui(scrollThumbFrame) then
							doTick()
						end
						wait()
					end
				end)

				newFrame.MouseWheelForward:Connect(function()
					self:ScrollTo(self.Index - self.WheelIncrement)
				end)

				newFrame.MouseWheelBackward:Connect(function()
					self:ScrollTo(self.Index + self.WheelIncrement)
				end)

				self.GuiElems.ScrollThumb = scrollThumb
				self.GuiElems.ScrollThumbFrame = scrollThumbFrame
				self.GuiElems.Button1 = button1
				self.GuiElems.Button2 = button2
				self.GuiElems.MarkerFrame = markerFrame

				return newFrame
			end

			funcs.Update = function(self,nocallback)
				local total = self.TotalSpace
				local visible = self.VisibleSpace
				local index = self.Index
				local button1 = self.GuiElems.Button1
				local button2 = self.GuiElems.Button2

				self.Index = math.clamp(self.Index,0,math.max(0,total-visible))

				if self.LastTotalSpace ~= self.TotalSpace then
					self.LastTotalSpace = self.TotalSpace
					self:UpdateMarkers()
				end

				if self:CanScrollUp() then
					for i,v in pairs(button1.Arrow:GetChildren()) do
						v.BackgroundTransparency = 0
					end
				else
					button1.BackgroundTransparency = 1
					for i,v in pairs(button1.Arrow:GetChildren()) do
						v.BackgroundTransparency = 0.5
					end
				end
				if self:CanScrollDown() then
					for i,v in pairs(button2.Arrow:GetChildren()) do
						v.BackgroundTransparency = 0
					end
				else
					button2.BackgroundTransparency = 1
					for i,v in pairs(button2.Arrow:GetChildren()) do
						v.BackgroundTransparency = 0.5
					end
				end

				drawThumb(self)
			end

funcs.UpdateMarkers = function(self)
				local markerFrame = self.GuiElems.MarkerFrame
				markerFrame:ClearAllChildren()

				for i,v in pairs(self.Markers) do
					if i < self.TotalSpace then
						createSimple("TextButton",{
							BackgroundTransparency = 0,
							BackgroundColor3 = v,
							BorderSizePixel = 0,
							Position = self.Horizontal and UDim2.new(i/self.TotalSpace,0,1,-6) or UDim2.new(1,-6,i/self.TotalSpace,0),
							Size = self.Horizontal and UDim2.new(0,1,0,6) or UDim2.new(0,6,0,1),
							Name = "Marker"..tostring(i),
							Parent = markerFrame,
							Text = "",
							AutoButtonColor = false,
						})
					end
				end
			end

			funcs.AddMarker = function(self,ind,color)
				self.Markers[ind] = color or Color3.new(0,0,0)
			end
			funcs.ScrollTo = function(self,ind,nocallback)
				self.Index = ind
				self:Update()
				if not nocallback then
					self.Scrolled:Fire()
				end
			end
			funcs.ScrollUp = function(self)
				self.Index = self.Index - self.Increment
				self:Update()
			end
			funcs.ScrollDown = function(self)
				self.Index = self.Index + self.Increment
				self:Update()
			end
			funcs.CanScrollUp = function(self)
				return self.Index > 0
			end
			funcs.CanScrollDown = function(self)
				return self.Index + self.VisibleSpace < self.TotalSpace
			end
			funcs.GetScrollPercent = function(self)
				return self.Index/(self.TotalSpace-self.VisibleSpace)
			end
			funcs.SetScrollPercent = function(self,perc)
				self.Index = math.floor(perc*(self.TotalSpace-self.VisibleSpace))
				self:Update()
			end

			funcs.Texture = function(self,data)
				self.ThumbColor = data.ThumbColor or Color3.new(0,0,0)
				self.ThumbSelectColor = data.ThumbSelectColor or Color3.new(0,0,0)
				self.GuiElems.ScrollThumb.BackgroundColor3 = data.ThumbColor or Color3.new(0,0,0)
				self.Gui.BackgroundColor3 = data.FrameColor or Color3.new(0,0,0)
				self.GuiElems.Button1.BackgroundColor3 = data.ButtonColor or Color3.new(0,0,0)
				self.GuiElems.Button2.BackgroundColor3 = data.ButtonColor or Color3.new(0,0,0)
				for i,v in pairs(self.GuiElems.Button1.Arrow:GetChildren()) do
					v.BackgroundColor3 = data.ArrowColor or Color3.new(0,0,0)
				end
				for i,v in pairs(self.GuiElems.Button2.Arrow:GetChildren()) do
					v.BackgroundColor3 = data.ArrowColor or Color3.new(0,0,0)
				end
			end

			funcs.SetScrollFrame = function(self,frame)
				if self.ScrollUpEvent then self.ScrollUpEvent:Disconnect() self.ScrollUpEvent = nil end
				if self.ScrollDownEvent then self.ScrollDownEvent:Disconnect() self.ScrollDownEvent = nil end
				self.ScrollUpEvent = frame.MouseWheelForward:Connect(function() self:ScrollTo(self.Index - self.WheelIncrement) end)
				self.ScrollDownEvent = frame.MouseWheelBackward:Connect(function() self:ScrollTo(self.Index + self.WheelIncrement) end)
			end

			local mt = {}
			mt.__index = funcs

			local function new(hor)
				local obj = setmetatable({
					Index = 0,
					VisibleSpace = 0,
					TotalSpace = 0,
					Increment = 1,
					WheelIncrement = 1,
					Markers = {},
					GuiElems = {},
					Horizontal = hor,
					LastTotalSpace = 0,
					Scrolled = Lib.Signal.new()
				},mt)
				obj.Gui = createFrame(obj)
				obj:Texture({
					ThumbColor = Color3.fromRGB(60,60,60),
					ThumbSelectColor = Color3.fromRGB(75,75,75),
					ArrowColor = Color3.new(1,1,1),
					FrameColor = Color3.fromRGB(40,40,40),
					ButtonColor = Color3.fromRGB(75,75,75)
				})
				return obj
			end

return {new = new}
		end)()
		Lib.CodeFrame = (function()
			local funcs = {}

			local typeMap = {
				[0] = "String",
				[1] = "String",
				[2] = "String",
				[3] = "String",
				[4] = "Comment",
				[5] = "Operator",
				[6] = "Number",
				[7] = "Keyword",
				[8] = "BuiltIn",
				[9] = "LocalMethod",
				[10] = "LocalProperty",
				[11] = "Nil",
				[12] = "Bool",
				[13] = "Function",
				[14] = "Local",
				[15] = "Self",
				[16] = "FunctionName",
				[17] = "Bracket"
			}

			local specialKeywordsTypes = {
				["nil"] = 11,
				["true"] = 12,
				["false"] = 12,
				["function"] = 13,
				["local"] = 14
			}

			local keywords = {
				["and"] = true,
				["break"] = true, 
				["do"] = true,
				["else"] = true,
				["elseif"] = true,
				["end"] = true,
				["false"] = true,
				["for"] = true,
				["function"] = true,
				["if"] = true,
				["in"] = true,
				["local"] = true,
				["nil"] = true,
				["not"] = true,
				["or"] = true,
				["repeat"] = true,
				["return"] = true,
				["then"] = true,
				["true"] = true,
				["until"] = true,
				["while"] = true,
				["type"] = true,
				["typeof"] = true,
				["self"] = true,
				["export"] = true,
				["continue"] = true,
				["OctoSpy"] = true,
				["Spy"] = true,
				["Octo"] = true
			}

			local builtIns = {}
			for i,_ in pairs(ENV) do
				builtIns[i] = true
			end

			local builtInInited = false

			local richReplace = {
				["'"] = "&apos;",
				["\""] = "&quot;",
				["<"] = "&lt;",
				[">"] = "&gt;",
				["&"] = "&amp;"
			}

			local tabSub = "\205"
			local tabReplacement = (" %s%s "):format(tabSub,tabSub)

			local tabJumps = {
				[("[^%s] %s"):format(tabSub,tabSub)] = 0,
				[(" %s%s"):format(tabSub,tabSub)] = -1,
				[("%s%s "):format(tabSub,tabSub)] = 2,
				[("%s [^%s]"):format(tabSub,tabSub)] = 1,
			}

			local tweenService = service.TweenService
			local lineTweens = {}

			local function initBuiltIn()
				local env = getfenv()
				local type = type
				local tostring = tostring
				for name,_ in next,builtIns do
					local envVal = env[name]
					if type(envVal) == "table" and name ~= "_G" then
						local items = {}
						for i,v in next,envVal do
							items[i] = true
						end
						builtIns[name] = items
					end
				end

				local enumEntries = {}
				local enums = Enum:GetEnums()
				for i = 1,#enums do
					enumEntries[tostring(enums[i])] = true
				end
				builtIns["Enum"] = enumEntries

				builtInInited = true
			end

			local function setupEditBox(obj)
				local editBox = obj.GuiElems.EditBox

				editBox.Focused:Connect(function()
					obj:ConnectEditBoxEvent()
					obj.Editing = true
				end)

				editBox.FocusLost:Connect(function()
					obj:DisconnectEditBoxEvent()
					obj.Editing = false
				end)

				editBox:GetPropertyChangedSignal("Text"):Connect(function()
					local text:string = editBox.Text
					if #text == 0 or obj.EditBoxCopying then return end
					editBox.Text = ""
					obj:AppendText(text:gsub("    ","    ").."")
				end)
			end

local function setupMouseSelection(obj)
				local mouse = plr and plr:GetMouse()
				local codeFrame = obj.GuiElems.LinesFrame
				local lines = obj.Lines

				codeFrame.InputBegan:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseButton1 then
						local fontSizeX,fontSizeY = math.ceil(obj.FontSize/2),obj.FontSize

						local relX = mouse.X - codeFrame.AbsolutePosition.X
						local relY = mouse.Y - codeFrame.AbsolutePosition.Y
						local selX = math.round(relX / fontSizeX) + obj.ViewX
						local selY = math.floor(relY / fontSizeY) + obj.ViewY
						local releaseEvent,mouseEvent,scrollEvent
						local scrollPowerV,scrollPowerH = 0,0
						selY = math.min(#lines-1,selY)
						local relativeLine = lines[selY+1] or ""
						selX = math.min(#relativeLine, selX + obj:TabAdjust(selX,selY))

						obj.SelectionRange = {{-1,-1},{-1,-1}}
						obj:MoveCursor(selX,selY)
						obj.FloatCursorX = selX

						local function updateSelection()
							local relX = mouse.X - codeFrame.AbsolutePosition.X
							local relY = mouse.Y - codeFrame.AbsolutePosition.Y
							local sel2X = math.max(0,math.round(relX / fontSizeX) + obj.ViewX)
							local sel2Y = math.max(0,math.floor(relY / fontSizeY) + obj.ViewY)

							sel2Y = math.min(#lines-1,sel2Y)
							local relativeLine = lines[sel2Y+1] or ""
							sel2X = math.min(#relativeLine, sel2X + obj:TabAdjust(sel2X,sel2Y))

							if sel2Y < selY or (sel2Y == selY and sel2X < selX) then
								obj.SelectionRange = {{sel2X,sel2Y},{selX,selY}}
							else                        
								obj.SelectionRange = {{selX,selY},{sel2X,sel2Y}}
							end

							obj:MoveCursor(sel2X,sel2Y)
							obj.FloatCursorX = sel2X
							obj:Refresh()
						end

						releaseEvent = service.UserInputService.InputEnded:Connect(function(input)
							if input.UserInputType == Enum.UserInputType.MouseButton1 then
								releaseEvent:Disconnect()
								mouseEvent:Disconnect()
								scrollEvent:Disconnect()
								obj:SetCopyableSelection()
								--updateSelection()
							end
						end)

						mouseEvent = service.UserInputService.InputChanged:Connect(function(input)
							if input.UserInputType == Enum.UserInputType.MouseMovement then
								local upDelta = mouse.Y - codeFrame.AbsolutePosition.Y
								local downDelta = mouse.Y - codeFrame.AbsolutePosition.Y - codeFrame.AbsoluteSize.Y
								local leftDelta = mouse.X - codeFrame.AbsolutePosition.X
								local rightDelta = mouse.X - codeFrame.AbsolutePosition.X - codeFrame.AbsoluteSize.X
								scrollPowerV = 0
								scrollPowerH = 0
								if downDelta > 0 then
									scrollPowerV = math.floor(downDelta*0.05) + 1
								elseif upDelta < 0 then
									scrollPowerV = math.ceil(upDelta*0.05) - 1
								end
								if rightDelta > 0 then
									scrollPowerH = math.floor(rightDelta*0.05) + 1
								elseif leftDelta < 0 then
									scrollPowerH = math.ceil(leftDelta*0.05) - 1
								end
								updateSelection()
							end
						end)

						scrollEvent = clonerefs(game:GetService("RunService")).RenderStepped:Connect(function()
							if scrollPowerV ~= 0 or scrollPowerH ~= 0 then
								obj:ScrollDelta(scrollPowerH,scrollPowerV)
								updateSelection()
							end
						end)

						obj:Refresh()
					end
				end)
			end

local function makeFrame(obj)
				local frame = create({
					{1,"TextButton",{AutoButtonColor=false,Text="",BackgroundColor3=Color3.new(0.15686275064945,0.15686275064945,0.15686275064945),BorderSizePixel = 0,Position=UDim2.new(0.5,-300,0.5,-200),Size=UDim2.new(0,600,0,400)}},
				})
				local elems = {}

				local linesFrame = Instance.new("Frame")
				linesFrame.Name = "Lines"
				linesFrame.BackgroundTransparency = 1
				linesFrame.Size = UDim2.new(1,0,1,0)
				linesFrame.ClipsDescendants = true
				linesFrame.Parent = frame

				local lineNumbersLabel = Instance.new("TextLabel")
				lineNumbersLabel.Name = "LineNumbers"
				lineNumbersLabel.BackgroundTransparency = 1
				lineNumbersLabel.Font = Enum.Font.Code
				lineNumbersLabel.TextXAlignment = Enum.TextXAlignment.Right
				lineNumbersLabel.TextYAlignment = Enum.TextYAlignment.Top
				lineNumbersLabel.ClipsDescendants = true
				lineNumbersLabel.RichText = true
				lineNumbersLabel.Parent = frame

				local cursor = Instance.new("TextButton")
				cursor.Name = "Cursor"
				cursor.BackgroundColor3 = Color3.fromRGB(220,220,220)
				cursor.BorderSizePixel = 0
				cursor.Parent = frame
				cursor.Text = ""
				cursor.AutoButtonColor = false

				local editBox = Instance.new("TextBox")
				editBox.Name = "EditBox"
				editBox.MultiLine = true
				editBox.Visible = false
				editBox.Parent = frame

				lineTweens.Invis = tweenService:Create(cursor,TweenInfo.new(0.4,Enum.EasingStyle.Quart,Enum.EasingDirection.Out),{BackgroundTransparency = 1})
				lineTweens.Vis = tweenService:Create(cursor,TweenInfo.new(0.2,Enum.EasingStyle.Quart,Enum.EasingDirection.Out),{BackgroundTransparency = 0})

				elems.LinesFrame = linesFrame
				elems.LineNumbersLabel = lineNumbersLabel
				elems.Cursor = cursor
				elems.EditBox = editBox
				elems.ScrollCorner = create({{1,"TextButton",{BackgroundColor3=Color3.new(0.15686275064945,0.15686275064945,0.15686275064945),BorderSizePixel=0,Name="ScrollCorner",Position=UDim2.new(1,-16,1,-16),Size=UDim2.new(0,16,0,16),Visible=false,Text="",AutoButtonColor=false}}})

				elems.ScrollCorner.Parent = frame
				linesFrame.InputBegan:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseButton1 then
						obj:SetEditing(true,input)
					end
				end)

				obj.Frame = frame
				obj.Gui = frame
				obj.GuiElems = elems
				setupEditBox(obj)
				setupMouseSelection(obj)

				return frame
			end

			funcs.GetSelectionText = function(self)
				if not self:IsValidRange() then return "" end

				local selectionRange = self.SelectionRange
				local selX,selY = selectionRange[1][1], selectionRange[1][2]
				local sel2X,sel2Y = selectionRange[2][1], selectionRange[2][2]
				local deltaLines = sel2Y-selY
				local lines = self.Lines

				if not lines[selY+1] or not lines[sel2Y+1] then return "" end

				if deltaLines == 0 then
					return self:ConvertText(lines[selY+1]:sub(selX+1,sel2X), false)
				end

				local leftSub = lines[selY+1]:sub(selX+1)
				local rightSub = lines[sel2Y+1]:sub(1,sel2X)

				local result = leftSub.."\n" 
				for i = selY+1,sel2Y-1 do
					result = result..lines[i+1].."\n"
				end
				result = result..rightSub

				return self:ConvertText(result,false)
			end

			funcs.SetCopyableSelection = function(self)
				local text = self:GetSelectionText()
				local editBox = self.GuiElems.EditBox

				self.EditBoxCopying = true
				editBox.Text = text
				editBox.SelectionStart = 1
				editBox.CursorPosition = #editBox.Text + 1
				self.EditBoxCopying = false
			end

			funcs.ConnectEditBoxEvent = function(self)
				if self.EditBoxEvent then
					self.EditBoxEvent:Disconnect()
				end

				self.EditBoxEvent = service.UserInputService.InputBegan:Connect(function(input)
					if input.UserInputType ~= Enum.UserInputType.Keyboard then return end

					local keycodes = Enum.KeyCode
					local keycode = input.KeyCode

					local function setupMove(key,func)
						local endCon,finished
						endCon = service.UserInputService.InputEnded:Connect(function(input)
							if input.KeyCode ~= key then return end
							endCon:Disconnect()
							finished = true
						end)
						func()
						Lib.FastWait(0.5)
						while not finished do func() Lib.FastWait(0.03) end
					end

					if keycode == keycodes.Down then
						setupMove(keycodes.Down,function()
							self.CursorX = self.FloatCursorX
							self.CursorY = self.CursorY + 1
							self:UpdateCursor()
							self:JumpToCursor()
						end)
					elseif keycode == keycodes.Up then
						setupMove(keycodes.Up,function()
							self.CursorX = self.FloatCursorX
							self.CursorY = self.CursorY - 1
							self:UpdateCursor()
							self:JumpToCursor()
						end)
					elseif keycode == keycodes.Left then
						setupMove(keycodes.Left,function()
							local line = self.Lines[self.CursorY+1] or ""
							self.CursorX = self.CursorX - 1 - (line:sub(self.CursorX-3,self.CursorX) == tabReplacement and 3 or 0)
if self.CursorX < 0 then
								self.CursorY = self.CursorY - 1
								local line2 = self.Lines[self.CursorY+1] or ""
								self.CursorX = #line2
							end
							self.FloatCursorX = self.CursorX
							self:UpdateCursor()
							self:JumpToCursor()
						end)
					elseif keycode == keycodes.Right then
						setupMove(keycodes.Right,function()
							local line = self.Lines[self.CursorY+1] or ""
							self.CursorX = self.CursorX + 1 + (line:sub(self.CursorX+1,self.CursorX+4) == tabReplacement and 3 or 0)
							if self.CursorX > #line then
								self.CursorY = self.CursorY + 1
								self.CursorX = 0
							end
							self.FloatCursorX = self.CursorX
							self:UpdateCursor()
							self:JumpToCursor()
						end)
					elseif keycode == keycodes.Backspace then
						setupMove(keycodes.Backspace,function()
							local startRange,endRange
							if self:IsValidRange() then
								startRange = self.SelectionRange[1]
								endRange = self.SelectionRange[2]
							else
								endRange = {self.CursorX,self.CursorY}
							end

							if not startRange then
								local line = self.Lines[self.CursorY+1] or ""
								self.CursorX = self.CursorX - 1 - (line:sub(self.CursorX-3,self.CursorX) == tabReplacement and 3 or 0)
								if self.CursorX < 0 then
									self.CursorY = self.CursorY - 1
									local line2 = self.Lines[self.CursorY+1] or ""
									self.CursorX = #line2
								end
								self.FloatCursorX = self.CursorX
								self:UpdateCursor()

								startRange = startRange or {self.CursorX,self.CursorY}
							end

							self:DeleteRange({startRange,endRange},false,true)
							self:ResetSelection(true)
							self:JumpToCursor()
						end)
					elseif keycode == keycodes.Delete then
						setupMove(keycodes.Delete,function()
							local startRange,endRange
							if self:IsValidRange() then
								startRange = self.SelectionRange[1]
								endRange = self.SelectionRange[2]
							else
								startRange = {self.CursorX,self.CursorY}
							end

							if not endRange then
								local line = self.Lines[self.CursorY+1] or ""
								local endCursorX = self.CursorX + 1 + (line:sub(self.CursorX+1,self.CursorX+4) == tabReplacement and 3 or 0)
								local endCursorY = self.CursorY
								if endCursorX > #line then
									endCursorY = endCursorY + 1
									endCursorX = 0
								end
								self:UpdateCursor()

								endRange = endRange or {endCursorX,endCursorY}
							end

							self:DeleteRange({startRange,endRange},false,true)
							self:ResetSelection(true)
							self:JumpToCursor()
						end)
					elseif service.UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
						if keycode == keycodes.A then
							self.SelectionRange = {{0,0},{#self.Lines[#self.Lines],#self.Lines-1}}
							self:SetCopyableSelection()
							self:Refresh()
						end
					end
				end)
			end

			funcs.DisconnectEditBoxEvent = function(self)
				if self.EditBoxEvent then
					self.EditBoxEvent:Disconnect()
				end
			end

			funcs.ResetSelection = function(self,norefresh)
				self.SelectionRange = {{-1,-1},{-1,-1}}
				if not norefresh then self:Refresh() end
			end

			funcs.IsValidRange = function(self,range)
				local selectionRange = range or self.SelectionRange
				local selX,selY = selectionRange[1][1], selectionRange[1][2]
				local sel2X,sel2Y = selectionRange[2][1], selectionRange[2][2]

				if selX == -1 or (selX == sel2X and selY == sel2Y) then return false end

				return true
			end

			funcs.DeleteRange = function(self,range,noprocess,updatemouse)
				range = range or self.SelectionRange
				if not self:IsValidRange(range) then return end

				local lines = self.Lines
				local selX,selY = range[1][1], range[1][2]
				local sel2X,sel2Y = range[2][1], range[2][2]
				local deltaLines = sel2Y-selY

				if not lines[selY+1] or not lines[sel2Y+1] then return end

				local leftSub = lines[selY+1]:sub(1,selX)
				local rightSub = lines[sel2Y+1]:sub(sel2X+1)
				lines[selY+1] = leftSub..rightSub

				local remove = table.remove
				for i = 1,deltaLines do
					remove(lines,selY+2)
				end

				if range == self.SelectionRange then self.SelectionRange = {{-1,-1},{-1,-1}} end
				if updatemouse then
					self.CursorX = selX
					self.CursorY = selY
					self:UpdateCursor()
				end

				if not noprocess then
					self:ProcessTextChange()
				end
			end

			funcs.AppendText = function(self,text)
				self:DeleteRange(nil,true,true)
				local lines,cursorX,cursorY = self.Lines,self.CursorX,self.CursorY
				local line = lines[cursorY+1]
				local before = line:sub(1,cursorX)
				local after = line:sub(cursorX+1)

				text = text:gsub("\r\n","\n")
				text = self:ConvertText(text,true) -- Tab Convert

				local textLines = text:split("\n")
				local insert = table.insert

for i = 1,#textLines do
					local linePos = cursorY+i
					if i > 1 then insert(lines,linePos,"") end

					local textLine = textLines[i]
					local newBefore = (i == 1 and before or "")
					local newAfter = (i == #textLines and after or "")

					lines[linePos] = newBefore..textLine..newAfter
				end

				if #textLines > 1 then cursorX = 0 end

				self:ProcessTextChange()
				self.CursorX = cursorX + #textLines[#textLines]
				self.CursorY = cursorY + #textLines-1
				self:UpdateCursor()
			end

			funcs.ScrollDelta = function(self,x,y)
				self.ScrollV:ScrollTo(self.ScrollV.Index + y)
				self.ScrollH:ScrollTo(self.ScrollH.Index + x)
			end

			-- x and y starts at 0
			funcs.TabAdjust = function(self,x,y)
				local lines = self.Lines
				local line = lines[y+1]
				x=x+1

				if line then
					local left = line:sub(x-1,x-1)
					local middle = line:sub(x,x)
					local right = line:sub(x+1,x+1)
					local selRange = (#left > 0 and left or " ") .. (#middle > 0 and middle or " ") .. (#right > 0 and right or " ")

					for i,v in pairs(tabJumps) do
						if selRange:find(i) then
							return v
						end
					end
				end
				return 0
			end

			funcs.SetEditing = function(self,on,input)            
				self:UpdateCursor(input)

				if on then
					if self.Editable then
						self.GuiElems.EditBox.Text = ""
						self.GuiElems.EditBox:CaptureFocus()
					end
				else
					self.GuiElems.EditBox:ReleaseFocus()
				end
			end

			funcs.CursorAnim = function(self,on)
				local cursor = self.GuiElems.Cursor
				local animTime = tick()
				self.LastAnimTime = animTime

				if not on then return end

				lineTweens.Invis:Cancel()
				lineTweens.Vis:Cancel()
				cursor.BackgroundTransparency = 0

				coroutine.wrap(function()
					while self.Editable do
						Lib.FastWait(0.5)
						if self.LastAnimTime ~= animTime then return end
						lineTweens.Invis:Play()
						Lib.FastWait(0.4)
						if self.LastAnimTime ~= animTime then return end
						lineTweens.Vis:Play()
						Lib.FastWait(0.2)
					end
				end)()
			end

			funcs.MoveCursor = function(self,x,y)
				self.CursorX = x
				self.CursorY = y
				self:UpdateCursor()
				self:JumpToCursor()
			end

			funcs.JumpToCursor = function(self)
				self:Refresh()
			end

			funcs.UpdateCursor = function(self,input)
				local linesFrame = self.GuiElems.LinesFrame
				local cursor = self.GuiElems.Cursor            
				local hSize = math.max(0,linesFrame.AbsoluteSize.X)
				local vSize = math.max(0,linesFrame.AbsoluteSize.Y)
				local maxLines = math.ceil(vSize / self.FontSize)
				local maxCols = math.ceil(hSize / math.ceil(self.FontSize/2))
				local viewX,viewY = self.ViewX,self.ViewY
				local totalLinesStr = tostring(#self.Lines)
				local fontWidth = math.ceil(self.FontSize / 2)
				local linesOffset = #totalLinesStr*fontWidth + 4*fontWidth

if input then
					local linesFrame = self.GuiElems.LinesFrame
					local frameX,frameY = linesFrame.AbsolutePosition.X,linesFrame.AbsolutePosition.Y
					local mouseX,mouseY = input.Position.X,input.Position.Y
					local fontSizeX,fontSizeY = math.ceil(self.FontSize/2),self.FontSize

					self.CursorX = self.ViewX + math.round((mouseX - frameX) / fontSizeX)
					self.CursorY = self.ViewY + math.floor((mouseY - frameY) / fontSizeY)
				end

				local cursorX,cursorY = self.CursorX,self.CursorY

				local line = self.Lines[cursorY+1] or ""
				if cursorX > #line then cursorX = #line
				elseif cursorX < 0 then cursorX = 0 end

				if cursorY >= #self.Lines then
					cursorY = math.max(0,#self.Lines-1)
				elseif cursorY < 0 then
					cursorY = 0
				end

				cursorX = cursorX + self:TabAdjust(cursorX,cursorY)

				-- Update modified
				self.CursorX = cursorX
				self.CursorY = cursorY

				local cursorVisible = (cursorX >= viewX) and (cursorY >= viewY) and (cursorX <= viewX + maxCols) and (cursorY <= viewY + maxLines)
				if cursorVisible then
					local offX = (cursorX - viewX)
					local offY = (cursorY - viewY)
					cursor.Position = UDim2.new(0,linesOffset + offX*math.ceil(self.FontSize/2) - 1,0,offY*self.FontSize)
					cursor.Size = UDim2.new(0,1,0,self.FontSize+2)
					cursor.Visible = true
					self:CursorAnim(true)
				else
					cursor.Visible = false
				end
			end

			funcs.MapNewLines = function(self)
				local newLines = {}
				local count = 1
				local text = self.Text
				local find = string.find
				local init = 1

				local pos = find(text,"\n",init,true)
				while pos do
					newLines[count] = pos
					count = count + 1
					init = pos + 1
					pos = find(text,"\n",init,true)
				end

				self.NewLines = newLines
			end

			funcs.PreHighlight = function(self)
				local start = tick()
				local text = self.Text:gsub("\\\\","  ")
				--print("BACKSLASH SUB",tick()-start)
				local textLen = #text
				local found = {}
				local foundMap = {}
				local extras = {}
				local find = string.find
				local sub = string.sub
				self.ColoredLines = {}

				local function findAll(str,pattern,typ,raw)
					local count = #found+1
					local init = 1
					local x,y,extra = find(str,pattern,init,raw)
					while x do
						found[count] = x
						foundMap[x] = typ
						if extra then
							extras[x] = extra
						end

						count = count+1
						init = y+1
						x,y,extra = find(str,pattern,init,raw)
					end
				end
				local start = tick()
				findAll(text,"`",0,true)
				findAll(text,'"',1,true)
				findAll(text,"'",2,true)
				findAll(text,"%[(=*)%[",3)
				findAll(text,"--",4,true)
				table.sort(found)

				local newLines = self.NewLines
				local curLine = 0
				local lineTableCount = 1
				local lineStart = 0
				local lineEnd = 0
				local lastEnding = 0
				local foundHighlights = {}

				for i = 1,#found do
					local pos = found[i]
					if pos <= lastEnding then continue end

for i = 1,#found do
					local pos = found[i]
					if pos <= lastEnding then continue end

					local ending = pos
					local typ = foundMap[pos]
					if typ == 0 then
						ending = find(text,"`",pos+1,true)
						while ending and sub(text,ending-1,ending-1) == "\\" do
							ending = find(text,"`",ending+1,true)
						end
						if not ending then ending = textLen end
					elseif typ == 1 then
						ending = find(text,'"',pos+1,true)
						while ending and sub(text,ending-1,ending-1) == "\\" do
							ending = find(text,'"',ending+1,true)
						end
						if not ending then ending = textLen end
					elseif typ == 2 then
						ending = find(text,"'",pos+1,true)
						while ending and sub(text,ending-1,ending-1) == "\\" do
							ending = find(text,"'",ending+1,true)
						end
						if not ending then ending = textLen end
					elseif typ == 3 then
						_,ending = find(text,"]"..extras[pos].."]",pos+1,true)
						if not ending then ending = textLen end
					elseif typ == 4 then
						local ahead = foundMap[pos+2]

						if ahead == 3 then
							_,ending = find(text,"]"..extras[pos+2].."]",pos+1,true)
							if not ending then ending = textLen end
						else
							ending = find(text,"\n",pos+1,true) or textLen
						end
					end

					while pos > lineEnd do
						curLine = curLine + 1
						--lineTableCount = 1
						lineEnd = newLines[curLine] or textLen+1
					end
					while true do
						local lineTable = foundHighlights[curLine]
						if not lineTable then lineTable = {} foundHighlights[curLine] = lineTable end
						lineTable[pos] = {typ,ending}
						--lineTableCount = lineTableCount + 1

						if ending > lineEnd then
							curLine = curLine + 1
							lineEnd = newLines[curLine] or textLen+1
						else
							break
						end
					end

					lastEnding = ending
					--if i < 200 then print(curLine) end
				end
				self.PreHighlights = foundHighlights
				--print(tick()-start)
				--print(#found,curLine)
			end

			funcs.HighlightLine = function(self,line)
				local cached = self.ColoredLines[line]
				if cached then return cached end

				local sub = string.sub
				local find = string.find
				local match = string.match
				local highlights = {}
				local preHighlights = self.PreHighlights[line] or {}
				local lineText = self.Lines[line] or ""
				local lineLen = #lineText
				local lastEnding = 0
				local currentType = 0
				local lastWord = nil
				local wordBeginsDotted = false
				local funcStatus = 0
				local lineStart = self.NewLines[line-1] or 0

				local preHighlightMap = {}
				for pos,data in next,preHighlights do
					local relativePos = pos-lineStart
					if relativePos < 1 then
						currentType = data[1]
						lastEnding = data[2] - lineStart
						--warn(pos,data[2])
					else
						preHighlightMap[relativePos] = {data[1],data[2]-lineStart}
					end
				end

				for col = 1,#lineText do
					if col <= lastEnding then highlights[col] = currentType continue end

					local pre = preHighlightMap[col]
					if pre then
						currentType = pre[1]
						lastEnding = pre[2]
						highlights[col] = currentType
						wordBeginsDotted = false
						lastWord = nil
						funcStatus = 0
					else
						local char = sub(lineText,col,col)
						if find(char,"[%a_]") then
							local word = match(lineText,"[%a%d_]+",col)
							local wordType = (keywords[word] and 7) or (builtIns[word] and 8)

							lastEnding = col+#word-1

							if wordType ~= 7 then
								if wordBeginsDotted then
									local prevBuiltIn = lastWord and builtIns[lastWord]
									wordType = (prevBuiltIn and type(prevBuiltIn) == "table" and prevBuiltIn[word] and 8) or 10

end

								if wordType ~= 8 then
									local x,y,br = find(lineText,"^%s*([%({\"'])",lastEnding+1)
									if x then
										wordType = (funcStatus > 0 and br == "(" and 16) or 9
										funcStatus = 0
									end
								end
							else
								wordType = specialKeywordsTypes[word] or wordType
								funcStatus = (word == "function" and 1 or 0)
							end

							lastWord = word
							wordBeginsDotted = false
							if funcStatus > 0 then funcStatus = 1 end

							if wordType then
								currentType = wordType
								highlights[col] = currentType
							else
								currentType = nil
							end
						elseif find(char,"%p") then
							local isDot = (char == ".")
							local isNum = isDot and find(sub(lineText,col+1,col+1),"%d")
							highlights[col] = (isNum and 6 or 5)

							if not isNum then
								local dotStr = isDot and match(lineText,"%.%.?%.?",col)
								if dotStr and #dotStr > 1 then
									currentType = 5
									lastEnding = col+#dotStr-1
									wordBeginsDotted = false
									lastWord = nil
									funcStatus = 0
								else
									if isDot then
										if wordBeginsDotted then
											lastWord = nil
										else
											wordBeginsDotted = true
										end
									else
										wordBeginsDotted = false
										lastWord = nil
									end

									funcStatus = ((isDot or char == ":") and funcStatus == 1 and 2) or 0
								end
							end
						elseif find(char,"%d") then
							local _,endPos = find(lineText,"%x+",col)
							local endPart = sub(lineText,endPos,endPos+1)
							if (endPart == "e+" or endPart == "e-") and find(sub(lineText,endPos+2,endPos+2),"%d") then
								endPos = endPos + 1
							end
							currentType = 6
							lastEnding = endPos
							highlights[col] = 6
							wordBeginsDotted = false
							lastWord = nil
							funcStatus = 0
						else
							highlights[col] = currentType
							local _,endPos = find(lineText,"%s+",col)
							if endPos then
								lastEnding = endPos
							end
						end
					end
				end

				self.ColoredLines[line] = highlights
				return highlights
			end

			funcs.Refresh = function(self)
				local start = tick()

				local linesFrame = self.Frame.Lines
				local hSize = math.max(0,linesFrame.AbsoluteSize.X)
				local vSize = math.max(0,linesFrame.AbsoluteSize.Y)
				local maxLines = math.ceil(vSize / self.FontSize)
				local maxCols = math.ceil(hSize / math.ceil(self.FontSize/2))
				local gsub = string.gsub
				local sub = string.sub

				local viewX,viewY = self.ViewX,self.ViewY

				local lineNumberStr = ""

				for row = 1,maxLines do
					local lineFrame = self.LineFrames[row]
					if not lineFrame then
						lineFrame = Instance.new("Frame")
						lineFrame.Name = "Line"
						lineFrame.Position = UDim2.new(0,0,0,(row-1)*self.FontSize)
						lineFrame.Size = UDim2.new(1,0,0,self.FontSize)
						lineFrame.BorderSizePixel = 0
						lineFrame.BackgroundTransparency = 1

						local selectionHighlight = Instance.new("Frame")
						selectionHighlight.Name = "SelectionHighlight"
						selectionHighlight.BorderSizePixel = 0
						selectionHighlight.BackgroundColor3 = Settings.Theme.Syntax.SelectionBack
						selectionHighlight.Parent = lineFrame

						local label = Instance.new("TextLabel")
						label.Name = "Label"
						label.BackgroundTransparency = 1
						label.Font = Enum.Font.Code
						label.TextSize = self.FontSize
						label.Size = UDim2.new(1,0,0,self.FontSize)
						label.RichText = true
						label.TextXAlignment = Enum.TextXAlignment.Left
						label.TextColor3 = self.Colors.Text
						label.ZIndex = 2
						label.Parent = lineFrame

						lineFrame.Parent = linesFrame
						self.LineFrames[row] = lineFrame
					end

local relaY = viewY + row
					local lineText = self.Lines[relaY] or ""
					local resText = ""
					local highlights = self:HighlightLine(relaY)
					local colStart = viewX + 1

					local richTemplates = self.RichTemplates
					local textTemplate = richTemplates.Text
					local selectionTemplate = richTemplates.Selection
					local curType = highlights[colStart]
					local curTemplate = richTemplates[typeMap[curType]] or textTemplate

					-- Selection Highlight
					local selectionRange = self.SelectionRange
					local selPos1 = selectionRange[1]
					local selPos2 = selectionRange[2]
					local selRow,selColumn = selPos1[2],selPos1[1]
					local sel2Row,sel2Column = selPos2[2],selPos2[1]
					local selRelaX,selRelaY = viewX,relaY-1

					if selRelaY >= selPos1[2] and selRelaY <= selPos2[2] then
						local fontSizeX = math.ceil(self.FontSize/2)
						local posX = (selRelaY == selPos1[2] and selPos1[1] or 0) - viewX
						local sizeX = (selRelaY == selPos2[2] and selPos2[1]-posX-viewX or maxCols+viewX)

						lineFrame.SelectionHighlight.Position = UDim2.new(0,posX*fontSizeX,0,0)
						lineFrame.SelectionHighlight.Size = UDim2.new(0,sizeX*fontSizeX,1,0)
						lineFrame.SelectionHighlight.Visible = true
					else
						lineFrame.SelectionHighlight.Visible = false
					end

					-- Selection Text Color for first char
					local inSelection = selRelaY >= selRow and selRelaY <= sel2Row and (selRelaY == selRow and viewX >= selColumn or selRelaY ~= selRow) and (selRelaY == sel2Row and viewX < sel2Column or selRelaY ~= sel2Row)
					if inSelection then
						curType = -999
						curTemplate = selectionTemplate
					end

					for col = 2,maxCols do
						local relaX = viewX + col
						local selRelaX = relaX-1
						local posType = highlights[relaX]

						-- Selection Text Color
						local inSelection = selRelaY >= selRow and selRelaY <= sel2Row and (selRelaY == selRow and selRelaX >= selColumn or selRelaY ~= selRow) and (selRelaY == sel2Row and selRelaX < sel2Column or selRelaY ~= sel2Row)
						if inSelection then
							posType = -999
						end

						if posType ~= curType then
							local template = (inSelection and selectionTemplate) or richTemplates[typeMap[posType]] or textTemplate

							if template ~= curTemplate then
								local nextText = gsub(sub(lineText,colStart,relaX-1),"['\"<>&]",richReplace)
								resText = resText .. (curTemplate ~= textTemplate and (curTemplate .. nextText .. "</font>") or nextText)
								colStart = relaX
								curTemplate = template
							end
							curType = posType
						end
					end

					local lastText = gsub(sub(lineText,colStart,viewX+maxCols),"['\"<>&]",richReplace)
					--warn("SUB",colStart,viewX+maxCols-1)
					if #lastText > 0 then
						resText = resText .. (curTemplate ~= textTemplate and (curTemplate .. lastText .. "</font>") or lastText)
					end

					if self.Lines[relaY] then
						lineNumberStr = lineNumberStr .. (relaY-1 == self.CursorY and ("<b>"..relaY.."</b>\n") or relaY .. "\n")
					end

					lineFrame.Label.Text = resText
				end

				for i = maxLines+1,#self.LineFrames do
					self.LineFrames[i]:Destroy()
					self.LineFrames[i] = nil
				end

				self.Frame.LineNumbers.Text = lineNumberStr
				self:UpdateCursor()

				--print("REFRESH TIME",tick()-start)
			end

			funcs.UpdateView = function(self)
				local totalLinesStr = tostring(#self.Lines)
				local fontWidth = math.ceil(self.FontSize / 2)
				local linesOffset = #totalLinesStr*fontWidth + 4*fontWidth

				local linesFrame = self.Frame.Lines
				local hSize = linesFrame.AbsoluteSize.X
				local vSize = linesFrame.AbsoluteSize.Y
				local maxLines = math.ceil(vSize / self.FontSize)
				local totalWidth = self.MaxTextCols*fontWidth
				local scrollV = self.ScrollV
				local scrollH = self.ScrollH

				scrollV.VisibleSpace = maxLines
				scrollV.TotalSpace = #self.Lines + 1
				scrollH.VisibleSpace = math.ceil(hSize/fontWidth)
				scrollH.TotalSpace = self.MaxTextCols + 1

				scrollV.Gui.Visible = #self.Lines + 1 > maxLines
				scrollH.Gui.Visible = totalWidth > hSize

				local oldOffsets = self.FrameOffsets
				self.FrameOffsets = Vector2.new(scrollV.Gui.Visible and -16 or 0, scrollH.Gui.Visible and -16 or 0)
				if oldOffsets ~= self.FrameOffsets then
					self:UpdateView()
				else
					scrollV:ScrollTo(self.ViewY,true)
					scrollH:ScrollTo(self.ViewX,true)

					if scrollV.Gui.Visible and scrollH.Gui.Visible then
						scrollV.Gui.Size = UDim2.new(0,16,1,-16)
						scrollH.Gui.Size = UDim2.new(1,-16,0,16)
						self.GuiElems.ScrollCorner.Visible = true
					else
						scrollV.Gui.Size = UDim2.new(0,16,1,0)
						scrollH.Gui.Size = UDim2.new(1,0,0,16)
						self.GuiElems.ScrollCorner.Visible = false
					end

					self.ViewY = scrollV.Index
					self.ViewX = scrollH.Index
					self.Frame.Lines.Position = UDim2.new(0,linesOffset,0,0)
					self.Frame.Lines.Size = UDim2.new(1,-linesOffset+oldOffsets.X,1,oldOffsets.Y)
					self.Frame.LineNumbers.Position = UDim2.new(0,fontWidth,0,0)
					self.Frame.LineNumbers.Size = UDim2.new(0,#totalLinesStr*fontWidth,1,oldOffsets.Y)
					self.Frame.LineNumbers.TextSize = self.FontSize
				end
			end

				end
			end
			new.Gui.Size = textbox.Size
			new.Gui.Position = textbox.Position
			new.Gui.AnchorPoint = textbox.AnchorPoint
			new.Gui.Visible = textbox.Visible
			textbox:Destroy()
			return setmetatable({},{
				__index = function(self,name)
					if name == "Text" then
						return new:GetText()
					else
						return new.Gui[name]
					end
				end,
				__newindex = function(self,name,val)
					if name == "Text" then
						new:SetText(val)
					else
						new.Gui[name] = val
					end
				end,
			})
		end
	end;
end;

-- Set scripts
do
	task.spawn(function() -- Instance1
		if not game:GetService("RunService"):IsClient() then return end
		local script = objects["Instance1"];
		local UI = script.Parent
		UI.Name = game:GetService("HttpService"):GenerateGUID(false):gsub("-", ""):sub(math.random(1, 16))

		local topbar = UI.Window
		local notifs = UI.Notifications
		local notif = UI.PCNotification

		local view = topbar.WindowView
		local viewScale = view.Scale

		local logs = view.Logs
		local content = view.ContentView
		local codeBox = content.CodeBox
		local code

		local log = logs.Log
		log.Parent = nil

		local function normalize(str)
			return str:gsub("\n", "\\n"):gsub("\t", "\\t"):gsub("\r", "\\r"):gsub("\"", "\\\"")..""
		end

		local childrenExist = {false, "a"}
		local function getPath(obj)
			if not obj then
				return "nil"
			elseif obj == workspace.Parent or obj == game then --[[it is different in some exploits :pray: :sob:, that's why i also use workspace.Parent]]
				return "game"
			elseif obj and not obj.Parent then
				local name = getfenv().getnilinstances and "getnilinstances" or getfenv().getnils and "getnils"
				if name then
					return "(function() local function getNil(objType, objName)\n    for i,v in "..name.."() do\n        if v.ClassName == objClass and v.Name == objName then\n            "
						.."return v\n        end\n    end\nend return getNil(\""..obj.ClassName.."\", \""..normalize(obj.Name).."\") end)()"
				else
					return "nil[\""..normalize(obj.Name).."\"] --[[ Object is parented to nil; getnilinstances does not exist in that exploit ]]"
				end
			end

			local path = ""
			while true do
				if obj.Parent == game or obj.Parent == workspace.Parent then
					path = ":GetService(\""..obj.ClassName:gsub(" ", "").."\")"..path
				elseif not obj.Parent then
					path = "game"..path
					return path:gsub("game%:GetService%(%\"Workspace%\"%)", "workspace") .. ""
				else
					childrenExist[1] = false
					childrenExist[2] = "a"

					for i,v in obj.Parent:GetChildren() do
						if v and v ~= obj and v.Name == obj.Name then
							childrenExist[1] = true
						elseif v == obj then
							childrenExist[2] = i
						end
					end
					if childrenExist[1] then
						if tonumber(childrenExist[2]) then
							path = ":GetChildren()["..childrenExist[2].."]"..path
						else
							path = ":WaitForChild(\""..normalize(obj.Name).."\", 9e9)"..path
						end
					else
						path = ":WaitForChild(\""..normalize(obj.Name).."\", 9e9)"..path
					end
				end

				obj = obj.Parent
			end
		end

		local tostr
		local ArgToString; ArgToString = function(arg)
			local type = typeof(arg)

			if type == "Instance" then
				return getPath(arg)
			elseif type == "number" or type == "boolean" or type == "nil" or type == "EnumItem" then
				return tostring(arg)
			elseif type == "string" then
				return "\""..normalize(arg).."\""
			elseif type == "function" then
				local s,n = pcall(debug.info, arg, "n")
				if s and n ~= "" then
					return "getfenv()[\""..normalize(n).."\"]"
				else
					return "function(...) return ... end --[[Unknown function: "..(not s and n or "Custom function").."]]"
				end
			elseif type == "table" then
				return tostr(arg)
			elseif type == "CFrame" or type == "Vector2" or type == "Vector3" or type == "Color3" or type == "UDim" or type == "UDim2" then
				return type..".new("..tostring(arg):gsub("{", ""):gsub("}", "")..")"
			elseif type == "Color3" then
				return "Color3.fromRGB("..tostring(arg)..")"
			elseif type == "BrickColor" then
				return "BrickColor.new(\""..arg.Name.."\")"
			elseif type == "Font" then
				return "Font.new(\""..arg.Family.."\", "..tostring(arg.Weight)..", "..tostring(arg.Style)..")"
			elseif type == "ColorSequence" or type == "NumberSequence" then
				return type..".new("..tostr(arg.Keypoints)..")"
			elseif type == "ColorSequenceKeypoint" or type == "NumberSequenceKeypoint" then
				return type..".new("..arg.Time..", "..ArgToString(arg.Value)..(type == "NumberSequenceKeypoint" and ", "..arg.Envelope or "")..")"
			elseif type == "NumberRange" then
				return type..".new("..arg.Min..", "..arg.Max..")"
			elseif type == "Enum" then
				return "Enum."..tostring(arg)
			elseif type == "Enums" then
				return "Enum"
			else
				return "--[[ Unknown type for ArgToString: \""..type.."\" ; Trying the awful method: type.new(tostring(arg)) ]] "..type..".new("..tostring(arg)..")"
			end
		end

tostr = function(tbl, ind)
			if typeof(tbl) == "table" then
				ind = ind or 1

				local gen = "{\n"
				for i,v in tbl do
					gen = gen..string.rep("    ", ind).."["..tostr(i, ind + 1).."] = "..tostr(v, ind + 1)..";\n"
				end
				if gen == "{\n" then
					gen = "{}"
				else
					gen = gen..string.rep("    ", ind - 1).."}"
				end

				return gen
			else
				return ArgToString(tbl)
			end
		end

		local tSize = topbar.Size
		local vSize = view.Size

		local spyActive = false
		local logBindables = false
		local insertionQueue = {}
		local cons = {}
		local hooks = {}

		local ignore = {}
		local block = {}

		log.Parent = nil
		topbar.Size = UDim2.fromScale(0,0)
		view.Size = UDim2.fromScale(1,0)
		topbar.Visible = false
		notifs.NotificationBase.Visible = false

		local delta, dragInput
		local function makeDraggable(gui, xOnly, minX, maxX)
			minX = tonumber(minX) or -math.huge
			maxX = tonumber(maxX) or  math.huge

			local dragging, dragStart, startPos, delta

			cons[#cons+1] = gui.InputBegan:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
					dragging = true
					dragStart = input.Position
					startPos = gui.Position

					cons[#cons+1] = input.Changed:Connect(function()
						if input.UserInputState == Enum.UserInputState.End then
							dragging = false
						end
					end)
				end
			end)

			cons[#cons+1] = gui.InputChanged:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
					dragInput = input
				end
			end)

			cons[#cons+1] = game:GetService("UserInputService").InputChanged:Connect(function(input)
				if input == dragInput and dragging then
					delta = input.Position - dragStart
					gui:TweenPosition(UDim2.new(startPos.X.Scale, math.clamp(startPos.X.Offset + delta.X, minX, maxX), not xOnly and startPos.Y.Scale or 0, not xOnly and startPos.Y.Offset + delta.Y or 0), nil, nil, 0.3, true)
					delta = nil
				end
			end)
		end

		makeDraggable(topbar)

		if not pcall(function()
				UI.Parent = game.CoreGui
			end) then
			UI.Parent = game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui", 9e9)
		end
		pcall(function()
			UI.OnTopOfCoreBlur = true
		end)

		local function colorButton(btn, hover, hoverCol, downCol)
			if not hover then
				hover = btn
			end
			local defCol = btn.BackgroundColor3
			if not hoverCol then
				hoverCol = Color3.new(math.clamp(defCol.R - 0.1, 0, 1), math.clamp(defCol.G - 0.1, 0, 1), math.clamp(defCol.B - 0.1, 0, 1))
			end
			if not downCol then
				downCol = Color3.new(math.clamp(hoverCol.R + 0.15, 0, 1), math.clamp(hoverCol.G + 0.15, 0, 1), math.clamp(hoverCol.B + 0.15, 0, 1))
			end
			hover.AutoButtonColor = false

			cons[#cons+1] = hover.MouseEnter:Connect(function()
				btn.BackgroundColor3 = hoverCol
			end)
			cons[#cons+1] = hover.MouseLeave:Connect(function()
				btn.BackgroundColor3 = defCol
			end)
			cons[#cons+1] = hover.MouseButton1Down:Connect(function()
				btn.BackgroundColor3 = downCol
			end)
			cons[#cons+1] = hover.MouseButton1Up:Connect(function()
				btn.BackgroundColor3 = defCol -- roblox's buttons work like that, nothing special
			end)
		end

colorButton(notif.Load.Display, notif.Load.Button, nil, Color3.new(0.6, 0.6, 0.8))
		colorButton(notif.Exit.Display, notif.Exit.Button, nil, Color3.new(0.6, 0.6, 0.8))
		colorButton(notif.Next.Display, notif.Next.Button, nil, Color3.new(0.6, 0.6, 0.8))
		colorButton(notif.Previous.Display, notif.Previous.Button, nil, Color3.new(0.6, 0.6, 0.8))

		local function notification(text, title)
			local notif = notifs.NotificationBase:Clone()
			notif.Parent = notifs
			notif.Visible = true
			notif.Size = UDim2.fromScale(1, 0)
			notif.Display.Position = UDim2.fromScale(1.5, 0.5)
			notif.Display.Title.Text = title or "Notification"
			notif.Display.Content.Text = text or "Just notification, nothing special"
			notif.Display.Bar.Frame.Size = UDim2.fromScale(1,1)
			notif:TweenSize(UDim2.new(1, 0, 0, 100), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.225, true)
			task.wait(0.225)
			notif.Display:TweenPosition(UDim2.fromScale(0.5, 0.5), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.775, true)
			notif.Display.Bar.Frame:TweenSize(UDim2.fromScale(0, 1), nil, Enum.EasingStyle.Linear, 4, true)
			task.wait(3.775)
			notif.Display:TweenPosition(UDim2.fromScale(1.5, 0.5), Enum.EasingDirection.In, Enum.EasingStyle.Sine, 0.225, true)
			task.wait(0.225)
			notif:TweenSize(UDim2.fromScale(1, 0), Enum.EasingDirection.In, Enum.EasingStyle.Sine, 0.225, true)
			task.wait(1)
			notif:Destroy()
		end

		local function close()
			spyActive = false
			logBindables = false
			for i,v in cons do
				v:Disconnect()
			end
			for i,v in hooks do
				task.spawn(v)
			end

			notifs:TweenPosition(UDim2.fromScale(1,1), Enum.EasingDirection.In, Enum.EasingStyle.Sine, 1, true)
			view:TweenSize(UDim2.fromScale(1,0), Enum.EasingDirection.In, Enum.EasingStyle.Sine, 0.4, true)
			topbar:TweenSize(UDim2.fromScale(0,0), Enum.EasingDirection.In, Enum.EasingStyle.Sine, 0.4, true)
			task.wait(0.245)
			topbar.Parent:Destroy()
			task.wait(1)
			UI:Destroy()
		end

		local soft = false
		local legacy = false
		local eventListener = false
		local weakHooks = 0

		if not game:GetService("UserInputService").TouchEnabled and game:GetService("UserInputService").KeyboardEnabled and (getfenv().hookmetamethod and getfenv().getnamecallmethod or getfenv().getcallbackvalue or getfenv().hookfunction) then
			notif.Visible = true
			local done = false
			local exit = false

			local modes = {
				{
					"Load [Normal]",
					Color3.fromRGB(255, 0, 127)
				},
				{
					"Load [Soft]",
					Color3.fromRGB(255, 85, 127),
					function()
						soft = true
					end,
					function()
						notification("Soft mode provides more stable experience, but it won't log RemoteFunction.OnClientInvoke" .. ((not getfenv().hookmetamethod or not getfenv().getnamecallmethod) and " and BindableFunction.OnInvoke (because hookmetamethod not" .. (getfenv().hookmetamethod and " fully" or "") .. " supported)" or ""), "Mode")
					end,
				},
				{
					"Load [Weak hooks]",
					Color3.fromRGB(85, 170, 127),
					function()
						weakHooks = 1
					end,
					function()
						notification("Weak hooks mode will use WAY LESS hookfunction", "Mode")
					end,
				},
				{
					"Load [Weaker hooks]",
					Color3.fromRGB(0, 170, 127),
					function()
						weakHooks = 2
					end,
					function()
						notification("Weaker hooks mode won't use hookfunction at all", "Mode")
					end,
				},
				{
					"Load [Soft + Weaker hooks]",
					Color3.fromRGB(85, 170, 0),
					function()
						soft = true
						weakHooks = 2
					end,
					function()
						notification("This one shouldn't crash", "Mode")
					end,
				},
				{
					"Load [Legacy]",
					Color3.fromRGB(255, 170, 127),
					function()
						legacy = true
					end,
					function()
						notification("Legacy mode provides very stable experience, but won't log stuff, that came from server to client (.OnClientEvent is an example)", "Mode")
					end,
				},
				{
					"Load [Legacy + Weaker hooks]",
					Color3.fromRGB(0, 85, 0),
					function()
						weakHooks = 2
						legacy = true
					end,
					function()
						notification("A spy with ultra weak hooks", "Mode")
					end,
				},
				{
					"Load [Weakest]",
					Color3.fromRGB(0, 0, 0),
					function()
						weakHooks = 2
						legacy = true
						soft = true
					end,
					function()
						notification("Theres no way it can crash", "Mode")
					end,
				},
				{
					"Load SimpleSpy",
					Color3.new(1, 1, 1),
					function()
						notif.Visible = false

						close()
						UI:Destroy()

						exit = true

						loadstring(game:HttpGet("https://raw.githubusercontent.com/infyiff/backup/main/SimpleSpyV3/main.lua"))()
					end,
					function()
						notification("Will unload OctoSpy and load SimpleSpy", "Mode")
					end
				}
			}

				cps = 0

				task.spawn(notification, easterMessages[times] or easterMessages[#easterMessages], "Easter egg")

				if not activated then
					activated = true

					titleTween1 = game:GetService("TweenService"):Create(topbar.Title, TweenInfo.new(0.35), {TextColor3 = Color3.new(0.75, 0.5, 0.75)})
					titleTween2 = game:GetService("TweenService"):Create(topbar.Title, TweenInfo.new(0.35), {TextColor3 = Color3.new(0.25, 0.75, 0.5)})

					titleTween1:Play()
				end

				repeat task.wait() until cps == 0
				task.wait(0.5)

				cd = false
			end
		end)

		task.spawn(function()
			while task.wait(1) and UI.Parent do
				cps = 0
			end
		end)

colorButton(topbar.Close, nil, Color3.new(1, 0.25, 0.25))
		cons[#cons+1] = topbar.Close.MouseButton1Click:Connect(close)
		local function updState1()
			local x = topbar.Toggle.State.ImageRectOffset.X == 32 and 48 or topbar.Toggle.State.ImageRectOffset.X == 48 and 112 or topbar.Toggle.State.ImageRectOffset.X == 112 and 32

			if x == 32 and legacy then
				x = 48
			end
			if x == 48 and (not getfenv().hookmetamethod or not getfenv().getnamecallmethod or not hf) then
				x = 112
			end

			topbar.Toggle.State.ImageRectOffset = Vector2.new(x, x == 112 and 0 or 16)

			logs.From:TweenPosition(UDim2.new(x == 48 and 0 or -1, 0, 0, -3), Enum.EasingDirection.InOut, Enum.EasingStyle.Sine, 0.4, true)
			logs.To:TweenPosition(UDim2.new(x == 32 and 0 or -1, 0, 0, -3), Enum.EasingDirection.InOut, Enum.EasingStyle.Sine, 0.4, true)
			spyActive = x ~= 112
			-- too lazy to make a variable
		end
		local function updState2()
			local x = topbar.Toggle2.State.ImageRectOffset.X == 112 and 208 or 112

			topbar.Toggle2.State.ImageRectOffset = Vector2.new(x, 0)

			logBindables = x == 208
			-- same here
		end

		if legacy and not (getfenv().hookmetamethod and getfenv().getnamecallmethod) then
			topbar.Toggle2.Visible = false
			topbar.Help.Position = topbar.Toggle2.Position
		end

		if getfenv().hookmetamethod and getfenv().getnamecallmethod and hf then
			if getfenv().getnilinstances and getfenv().getinstances and getfenv().firesignal and getfenv().getcallbackvalue then
				task.spawn(notification, "That executor fully supports Octo~Spy (and simple spy)", "Supported")
			else
				task.spawn(notification, "That executor not fully supports Octo~Spy (but possibly supports simple spy)", "Supported")
			end
		else
			task.spawn(notification, "That does not fully support Octo~Spy (simple spy probably wont work)", "Unsupported")
		end

		cons[#cons+1] = topbar.Toggle.MouseButton1Click:Connect(updState1)
		cons[#cons+1] = topbar.Toggle2.MouseButton1Click:Connect(updState2)
		cons[#cons+1] = topbar.Help.MouseButton1Click:Connect(function()
			notification("Help button is coming soon!", "Coming soon")
		end)

		updState1()
		updState2()

		local offsetSize = logs.Size.X.Offset

		makeDraggable(viewScale, true, 80, 350)

		local sizeDiv = 6

		local function func(v, old, ...)
			local args = { ... }
			local args = tostr(args)
			local n:string = v.Name
			if #n >= math.floor(offsetSize/sizeDiv) then
				n = n:sub(0, math.floor(offsetSize/sizeDiv)).."..."
			end

			local log = log:Clone()
			log.Visible = true
			log.Display.Type.BackgroundColor3 = v.ClassName == "RemoteFunction" and Color3.new(0.77, 0.44, 1) or Color3.new(0.33, 0.11, 0.66)
			log.Display.RName.Text = n
			log.Display.FromServer.Visible = true
			log.Display.RName.TextColor3 = not block[v.Name] and not block[v] and Color3.new(1,1,1) or Color3.new(1, 0.5, 0.5)
			local msg
			if v.ClassName == "RemoteFunction" then
				msg = "local args = "..args.."\n\ngetcallbackvalue("..tostr(v)..", \"OnClientInvoke\")(unpack(args)) -- OnClientInvoke"
			else
				msg = "local args = "..args.."\n\n"..tostr(v)..":Invoke(unpack(args)) -- OnInvoke"
			end

			local t = {log, "From", msg, nil, v, args, "Invoke"}
			table.insert(insertionQueue, t)

			if not block[v.Name] and not block[v] then
				local res = {old(...)}
				t[4] = res

				return unpack(res)
			end
		end

		local function remoteEvent(v, ...)
			if spyActive and not ignore[v.Name] and not ignore[v] then
				local args = { ... }
				table.remove(args, 1) -- remove first argument, because it is "self"

				args = tostr(args)
				local n = v.Name
				if #n >= math.floor(offsetSize/sizeDiv) then
					n = n:sub(0, math.floor(offsetSize/sizeDiv)).."..."
				end

				local log = log:Clone()
				log.Visible = true
				log.Display.Type.BackgroundColor3 = v.ClassName == "UnreliableRemoteEvent" and Color3.new(1, 0.66, 0) or Color3.new(1, 0.88, 0)
				log.Display.RName.Text = n
				log.Display.RName.TextColor3 = not block[v.Name] and not block[v] and Color3.new(1,1,1) or Color3.new(1, 0.5, 0.5)

				local txt = "local args = "..args.."\n\n"
				if fs ~= 0 then
					txt = txt.."firesignal("..tostr(v) .. (fs == 1 and ", \"OnClientEvent\"" or ".OnClientEvent") .. ", unpack(args))"
				else
					txt = txt.."-- "..tostr(v)
				end
				table.insert(insertionQueue, {log, "From", txt.." -- OnClientEvent", nil, v, args, "Run"})
			end
		end

local function bindableEvent(v, ...)
			if spyActive and logBindables and not ignore[v.Name] and not ignore[v] then
				local args = { ... }
				table.remove(args, 1) -- remove first argument, because it is "self"

				args = tostr(args)
				local n = v.Name
				if #n >= math.floor(offsetSize/sizeDiv) then
					n = n:sub(0, math.floor(offsetSize/sizeDiv)).."..."
				end

				local log = log:Clone()
				log.Visible = true
				log.Display.Type.BackgroundColor3 = Color3.new(1, 0.7, 0.3)
				log.Display.RName.Text = n
				log.Display.FromServer.Visible = true
				log.Display.RName.TextColor3 = not block[v.Name] and not block[v] and Color3.new(1,1,1) or Color3.new(1, 0.5, 0.5)

				table.insert(insertionQueue, {log, "From", "local args = "..args.."\n\n"..tostr(v)..":Fire(unpack(args)) -- Event", nil, v, args, "Fire"})
			end
		end

		local function rf(v)
			local name = v.ClassName == "RemoteFunction" and "OnClientInvoke" or "OnInvoke"
			local cbval = getfenv().getcallbackvalue(v, name)
			if cbval and weakHooks ~= 2 then
				local old; old = getfenv().hookfunction(cbval, newl(newc(function(...) -- i'm doing newlclosure(newclosure(luaClose)) because for some reason it crashed without that
					if (v.ClassName == "BindableFunction" and logBindables or v.ClassName ~= "BindableFunction") and spyActive and not ignore[v.Name] and not ignore[v] then
						return func(v, old, ...)
					end

					if block[v.Name] or block[v] then return end
					return old(...)
				end)))
				hooks[#hooks+1] = function()
					getfenv().hookfunction(cbval, old)
				end
			end
		end
		local function main(v:Instance)
			if typeof(v) == "Instance" then
				if v.ClassName == "RemoteEvent" or v.ClassName == "UnreliableRemoteEvent" then
					cons[#cons+1] = v.OnClientEvent:Connect(function(...)
						remoteEvent(v, ...)
					end)
				elseif getfenv().getcallbackvalue and hf and v.ClassName == "RemoteFunction" and not soft then
					local s,e = pcall(rf, v)
					if not s then
						--warn(e)
					end
				elseif not getfenv().hookmetamethod or not hf or not getfenv().getnamecallmethod then
					if v.ClassName == "BindableEvent" then
						cons[#cons+1] = v.Event:Connect(function(...)
							bindableEvent(v, ...)
						end)
					elseif getfenv().getcallbackvalue and hf and v.ClassName == "BindableFunction" and not soft then
						local s,e = pcall(rf, v)
						if not s then
							--warn(e)
						end
					end
				end
			end
		end

		local enums = 0
		local enumCalls = 0
		local function enumerate(list)
			enumCalls += 1

			for i,v in list do
				main(v)
				if i % 750 == 0 then
					task.wait()
					game:GetService("RunService").RenderStepped:Wait()
					task.wait()
				end
			end

			enums += 1
		end

		if not legacy then
			--task.spawn(enumerate, game:GetDescendants())
			local l1 = getfenv().getinstances and getfenv().getinstances() or game:GetDescendants()
			local l2 = getfenv().getnilinstances and getfenv().getnilinstances() or {}

			task.spawn(enumerate, l1)
			task.spawn(enumerate, l2)
		end

		cons[#cons+1] = game.DescendantAdded:Connect(main)

		local obj = Instance.new("RemoteEvent")
		local fireServer = obj.FireServer
		obj:Destroy()
		local obj = Instance.new("UnreliableRemoteEvent")
		local fireServer2 = obj.FireServer
		obj:Destroy()
		local obj = Instance.new("RemoteFunction")
		local invokeServer = obj.InvokeServer
		obj:Destroy()
		local obj = Instance.new("BindableEvent")
		local fire = obj.Fire
		obj:Destroy()
		local obj = Instance.new("BindableFunction")
		local invoke = obj.Invoke
		obj:Destroy()

		local old1, old2, old3, old4, old5 = fireServer, fireServer2, invokeServer, fire, invoke
		local fireServerHook, fireServer2Hook, invokeServerHook, fireHook, invokeHook = (newc(function(...)
			local self = ...
			if typeof(self) ~= "Instance" or self.ClassName ~= "RemoteEvent" then
				return old1(...)
			end
			if not spyActive then
				return not block[self] and not block[self.Name] and old1(...)
			end

			if not ignore[self] and not ignore[self.Name] then
				local args = { ... }
				table.remove(args, 1) -- remove first argument, because it is "self"

				args = tostr(args)
				local n = self.Name
				if #n >= math.floor(offsetSize/sizeDiv) then
					n = n:sub(0, math.floor(offsetSize/sizeDiv)).."..."
				end

				local log = log:Clone()
				log.Visible = true
				log.Display.Type.BackgroundColor3 = Color3.new(1, 0.66, 0)
				log.Display.RName.Text = n
				log.Display.RName.TextColor3 = not block[self.Name] and not block[self] and Color3.new(1,1,1) or Color3.new(1, 0.5, 0.5)

				table.insert(insertionQueue, {log, "To", "local args = "..args.."\n\n"..tostr(self)..":FireServer(unpack(args))", nil, self, args, "FireServer"})
			end

			if block[self.Name] or block[self] then return end
			return old1(...)
		end)), (newc(function(...)
			local self = ...
			if typeof(self) ~= "Instance" or self.ClassName ~= "UnreliableRemoteEvent" then
				return old2(...)
			end
			if not spyActive then
				return not block[self] and not block[self.Name] and old2(...)
			end

			if not ignore[self] and not ignore[self.Name] then
				local args = { ... }
				table.remove(args, 1) -- remove first argument, because it is "self"

				args = tostr(args)
				local n = self.Name
				if #n >= math.floor(offsetSize/sizeDiv) then
					n = n:sub(0, math.floor(offsetSize/sizeDiv)).."..."
				end

				local log = log:Clone()
				log.Visible = true
				log.Display.Type.BackgroundColor3 = Color3.new(1, 0.44, 0.22)
				log.Display.RName.Text = n
				log.Display.RName.TextColor3 = not block[self.Name] and not block[self] and Color3.new(1,1,1) or Color3.new(1, 0.5, 0.5)

				table.insert(insertionQueue, {log, "To", "local args = "..args.."\n\n"..tostr(self)..":FireServer(unpack(args)) -- Unreliable FireServer", nil, self, args, "FireServer"})
			end

if block[self.Name] or block[self] then return end
				local res = {old3(...)}
				t[4] = res

				return unpack(res)
			end

			if block[self.Name] or block[self] then return end
			return old3(...)
		end)), (newc(function(...)
			local self = ...
			if typeof(self) ~= "Instance" or self.ClassName ~= "BindableEvent" then
				return old4(...)
			end
			bindableEvent(...)
			if block[self.Name] or block[self] then return end
			return old4(...)
		end)), (newc(function(...)
			local self = ...
			if typeof(self) ~= "Instance" or self.ClassName ~= "BindableFunction" then
				return old5(...)
			end
			return func(old5, ...)
		end))

		if hf and getfenv().hookmetamethod and getfenv().getnamecallmethod and weakHooks < 2 then
			old1 = getfenv().hookfunction(fireServer, fireServerHook)
			hooks[#hooks+1] = function()
				getfenv().hookfunction(fireServer, old1)
			end
			old2 = getfenv().hookfunction(fireServer2, fireServer2Hook)
			hooks[#hooks+1] = function()
				getfenv().hookfunction(fireServer2, old2)
			end
			old3 = getfenv().hookfunction(invokeServer, invokeServerHook)
			hooks[#hooks+1] = function()
				getfenv().hookfunction(invokeServer, old3)
			end
			old4 = getfenv().hookfunction(fire, fireHook)
			hooks[#hooks+1] = function()
				getfenv().hookfunction(fire, old4)
			end
			old5 = getfenv().hookfunction(invoke, invokeHook)
			hooks[#hooks+1] = function()
				getfenv().hookfunction(invoke, old5)
			end
		end

task.spawn(function()
			repeat task.wait() until game:IsLoaded()
			task.wait(2.5)

			view:TweenSize(vSize, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.4, true)
			topbar:TweenSize(tSize, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.4, true)
			task.wait(0.1)
			topbar.Visible = true

			repeat task.wait() until enums == enumCalls

			notification("Octo~Spy fully loaded!\nShould log everything now.", "Fully loaded")
		end)

		code = require(script:FindFirstChildOfClass("ModuleScript"))(content.CodeBox)
		code.Text = "Welcome to the " .. topbar.Title.Text .. "!"
	end);
end;

